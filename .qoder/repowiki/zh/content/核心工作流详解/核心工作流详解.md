# 核心工作流详解

<cite>
**本文档引用文件**  
- [constitution.md](file://templates/commands/constitution.md)
- [specify.md](file://templates/commands/specify.md)
- [plan.md](file://templates/commands/plan.md)
- [tasks.md](file://templates/commands/tasks.md)
- [clarify.md](file://templates/commands/clarify.md)
- [implement.md](file://templates/commands/implement.md)
- [analyze.md](file://templates/commands/analyze.md)
- [spec-template.md](file://templates/spec-template.md)
- [plan-template.md](file://templates/plan-template.md)
- [tasks-template.md](file://templates/tasks-template.md)
- [constitution.md](file://memory/constitution.md)
- [README.md](file://README.md)
- [spec-driven.md](file://spec-driven.md)
</cite>

## 目录
1. [引言](#引言)
2. [核心命令功能解析](#核心命令功能解析)
3. [工作流执行流程](#工作流执行流程)
4. [模板结构设计分析](#模板结构设计分析)
5. [闭环开发流水线](#闭环开发流水线)
6. [实际工作流示例](#实际工作流示例)
7. [工作流调整与扩展](#工作流调整与扩展)
8. [结论](#结论)

## 引言

Spec-Kit 是一个基于规范驱动开发（Spec-Driven Development, SDD）的软件开发框架，其核心工作流通过一系列斜杠命令（/command）实现从需求到实现的自动化流程。该工作流以结构化模板和AI代理协同为基础，确保开发过程的可追溯性、一致性和高质量。

本文档深入解析Spec-Kit的核心工作流机制，详细阐述每个命令的功能定位、执行时机及其在整体流程中的作用。通过分析`templates/commands/`目录下的Markdown模板文件，揭示其指令说明、预期输出格式以及与AI代理的交互方式。最终展示这些命令如何形成一个闭环的开发流水线，从需求澄清到最终实现。

## 核心命令功能解析

### /constitution 命令

`/constitution` 命令用于创建或更新项目的宪法文件（`/memory/constitution.md`），该文件定义了项目的治理原则、开发规范和质量标准。

**功能定位**：作为整个开发流程的"宪法"，为所有后续开发活动提供约束和指导。它确保所有技术决策和实现都符合项目的核心原则。

**执行时机**：在项目初始化阶段首次执行，后续在需要更新项目原则或治理规则时再次执行。

**在整体流程中的作用**：
- 定义项目的核心原则（如库优先、CLI接口、测试先行等）
- 建立版本控制和修订流程
- 为后续的`/plan`和`/analyze`命令提供合规性检查依据
- 确保所有生成的文档和代码都遵循统一的架构原则

**Section sources**
- [constitution.md](file://templates/commands/constitution.md#L1-L73)
- [memory/constitution.md](file://memory/constitution.md#L1-L50)

### /specify 命令

`/specify` 命令用于根据自然语言描述创建或更新功能规格文档。

**功能定位**：将用户的功能描述转化为结构化的功能规格文档，是开发流程的起点。

**执行时机**：在确定新功能需求后立即执行，通常在`/constitution`之后。

**在整体流程中的作用**：
- 自动创建功能分支和相关目录结构
- 基于`spec-template.md`生成标准化的规格文档
- 提取关键概念（参与者、动作、数据、约束）
- 标记不明确的需求点（使用`[NEEDS CLARIFICATION]`标记）
- 生成可测试的功能需求和用户故事

**Section sources**
- [specify.md](file://templates/commands/specify.md#L1-L24)
- [spec-template.md](file://templates/spec-template.md#L1-L116)

### /plan 命令

`/plan` 命令用于执行实施规划工作流，生成设计文档。

**功能定位**：将功能规格转化为技术实现计划，连接业务需求与技术实现。

**执行时机**：在完成`/specify`并确保规格文档完整后执行，通常在`/clarify`之后。

**在整体流程中的作用**：
- 分析功能规格文档，理解需求和用户故事
- 检查宪法合规性，确保技术方案符合项目原则
- 执行实施计划模板，生成研究文档、数据模型、API合同等设计产物
- 为后续的`/tasks`命令提供输入
- 实现从"做什么"到"怎么做"的转换

**Section sources**
- [plan.md](file://templates/commands/plan.md#L1-L46)
- [plan-template.md](file://templates/plan-template.md#L1-L225)

### /tasks 命令

`/tasks` 命令用于基于可用的设计文档生成可操作的、依赖关系有序的任务列表。

**功能定位**：将设计文档转化为具体的实施任务，为代码实现提供明确指引。

**执行时机**：在完成`/plan`并生成所有设计文档后执行。

**在整体流程中的作用**：
- 分析设计文档（`plan.md`、`data-model.md`、`contracts/`等）
- 根据设计产物生成具体任务（设置任务、测试任务、核心任务等）
- 按照依赖关系对任务进行排序（TDD原则：测试优先）
- 标记可并行执行的任务（[P]标记）
- 生成立即可执行的`tasks.md`文件

**Section sources**
- [tasks.md](file://templates/commands/tasks.md#L1-L65)
- [tasks-template.md](file://templates/tasks-template.md#L1-L126)

### /clarify 命令

`/clarify` 命令用于识别当前功能规格中的不明确区域，并通过提问和记录答案来减少歧义。

**功能定位**：在规划前进行需求澄清，降低下游返工风险。

**执行时机**：在`/specify`之后、`/plan`之前执行，是可选但推荐的步骤。

**在整体流程中的作用**：
- 结构化扫描规格文档的模糊性（功能范围、数据模型、交互流程等）
- 生成最多5个高度针对性的澄清问题
- 将用户答案直接编码回规格文档
- 更新相关章节（功能需求、用户故事、数据模型等）
- 确保规格文档的完整性和明确性

**Section sources**
- [clarify.md](file://templates/commands/clarify.md#L1-L161)

### /analyze 命令

`/analyze` 命令用于在任务生成后对核心文档进行一致性与质量分析。

**功能定位**：在实施前进行跨文档一致性检查，确保开发准备就绪。

**执行时机**：在`/tasks`成功生成`tasks.md`后、`/implement`之前执行。

**在整体流程中的作用**：
- 识别`spec.md`、`plan.md`、`tasks.md`之间的不一致
- 检测重复、模糊、未充分说明的项目
- 验证与宪法文件的对齐情况
- 生成结构化分析报告和改进建议
- 提供实施前的最终质量门禁

**Section sources**
- [analyze.md](file://templates/commands/analyze.md#L1-L104)

### /implement 命令

`/implement` 命令用于执行实施计划，处理并执行`tasks.md`中定义的所有任务。

**功能定位**：自动化执行开发任务，将设计转化为代码实现。

**执行时机**：在完成`/analyze`并确认无严重问题后执行。

**在整体流程中的作用**：
- 解析`tasks.md`中的任务列表和执行计划
- 按阶段（设置、测试、核心、集成、完善）执行任务
- 遵循TDD方法：先执行测试任务，再执行实现任务
- 跟踪进度并在任务完成后标记
- 验证所有任务完成并符合原始规格

**Section sources**
- [implement.md](file://templates/commands/implement.md#L1-L58)

## 工作流执行流程

```mermaid
flowchart TD
A[/constitution\n创建项目宪法] --> B[/specify\n创建功能规格]
B --> C[/clarify\n需求澄清\n(可选)]
C --> D[/plan\n生成技术计划]
D --> E[/tasks\n生成任务列表]
E --> F[/analyze\n一致性分析]
F --> G[/implement\n执行实现]
G --> H[完成开发]
style A fill:#f9f,stroke:#333
style B fill:#f9f,stroke:#333
style C fill:#ff9,stroke:#333
style D fill:#f9f,stroke:#333
style E fill:#f9f,stroke:#333
style F fill:#f9f,stroke:#333
style G fill:#f9f,stroke:#333
style H fill:#9f9,stroke:#333
classDef command fill:#f9f,stroke:#333;
classDef optional fill:#ff9,stroke:#333;
classDef final fill:#9f9,stroke:#333;
class A,B,D,E,F,G command
class C optional
class H final
```

**Diagram sources**
- [README.md](file://README.md#L100-L150)
- [spec-driven.md](file://spec-driven.md#L200-L250)

## 模板结构设计分析

### 规格模板 (spec-template.md)

规格模板的设计旨在引导AI代理生成高质量、可执行的规格文档。

**核心设计特点**：
- **明确的指导原则**：强调关注"做什么"而非"如何做"
- **结构化章节**：强制包含用户场景、功能需求、关键实体等必要部分
- **模糊性标记**：使用`[NEEDS CLARIFICATION]`明确标记不确定的需求
- **审查清单**：内置自动化检查，确保内容质量和完整性
- **执行流程**：定义了从用户描述到规格生成的明确步骤

**Section sources**
- [spec-template.md](file://templates/spec-template.md#L1-L116)

### 计划模板 (plan-template.md)

计划模板将技术规划过程结构化，确保设计的一致性和合规性。

**核心设计特点**：
- **宪法检查**：在设计前后进行合规性验证
- **分阶段执行**：明确划分为研究、设计、任务规划等阶段
- **技术上下文**：要求明确语言、依赖、存储等技术细节
- **复杂性跟踪**：记录对宪法原则的任何偏离及其理由
- **进度跟踪**：提供可视化的执行状态检查

**Section sources**
- [plan-template.md](file://templates/plan-template.md#L1-L225)

### 任务模板 (tasks-template.md)

任务模板将设计文档转化为具体的实施任务，确保执行的可操作性。

**核心设计特点**：
- **任务分类**：按设置、测试、核心、集成、完善等类别组织
- **依赖关系**：明确任务间的先后顺序和依赖
- **并行标记**：使用`[P]`标记可并行执行的任务
- **路径约定**：提供不同项目结构的路径示例
- **验证清单**：确保任务生成的完整性和正确性

**Section sources**
- [tasks-template.md](file://templates/tasks-template.md#L1-L126)

## 闭环开发流水线

```mermaid
graph LR
A[需求输入] --> B[/specify\n规格生成]
B --> C[/clarify\n需求澄清]
C --> D[/plan\n技术规划]
D --> E[/tasks\n任务分解]
E --> F[/analyze\n一致性分析]
F --> G[/implement\n代码实现]
G --> H[可运行系统]
H --> I[用户反馈]
I --> A
style A fill:#aqua,stroke:#333
style B fill:#f9f,stroke:#333
style C fill:#ff9,stroke:#333
style D fill:#f9f,stroke:#333
style E fill:#f9f,stroke:#333
style F fill:#f9f,stroke:#333
style G fill:#f9f,stroke:#333
style H fill:#9f9,stroke:#333
style I fill:#aqua,stroke:#333
classDef inputOutput fill:#aqua,stroke:#333;
classDef command fill:#f9f,stroke:#333;
classDef result fill:#9f9,stroke:#333;
class A,I inputOutput
class B,C,D,E,F,G command
class H result
```

**Diagram sources**
- [spec-driven.md](file://spec-driven.md#L50-L100)
- [README.md](file://README.md#L200-L250)

## 实际工作流示例

### 场景：开发照片管理应用

1. **建立项目原则**
```bash
/constitution 创建关注代码质量、测试标准、用户体验一致性和性能要求的原则
```

2. **创建功能规格**
```bash
/specify 构建一个应用，帮助我将照片组织到单独的相册中。相册按日期分组，可以在主页面上通过拖放重新组织。相册从不嵌套在其他相册中。在每个相册内，照片以类似图块的界面预览。
```

3. **需求澄清（可选）**
```bash
/clarify
```
*系统将提出最多5个针对性问题，如：*
- 相册的命名规则是什么？
- 照片的元数据包含哪些字段？
- 拖放操作的性能目标是多少？

4. **生成技术计划**
```bash
/plan 应用使用Vite，尽量减少库的数量。尽可能使用原生HTML、CSS和JavaScript。图片不上传到任何地方，元数据存储在本地SQLite数据库中。
```

5. **生成任务列表**
```bash
/tasks
```

6. **一致性分析**
```bash
/analyze
```

7. **执行实现**
```bash
/implement
```

**Section sources**
- [README.md](file://README.md#L150-L200)
- [spec-driven.md](file://spec-driven.md#L300-L350)

## 工作流调整与扩展

### 调整工作流

根据项目需要，可以对标准工作流进行调整：

**简化流程**（快速原型）
- 跳过`/clarify`步骤
- 合并`/plan`和`/tasks`步骤
- 直接进入`/implement`

**增强流程**（关键系统）
- 增加安全审查步骤
- 添加性能基准测试
- 引入人工代码审查环节
- 增加用户验收测试

### 扩展工作流

可以通过以下方式扩展工作流：

**自定义命令**
- 创建`/security`命令进行安全审查
- 创建`/performance`命令进行性能分析
- 创建`/docs`命令生成用户文档

**模板定制**
- 根据项目类型定制规格模板
- 为特定技术栈定制计划模板
- 为不同团队定制任务模板

**自动化集成**
- 与CI/CD系统集成
- 与项目管理工具（Jira等）同步
- 与监控系统集成

**Section sources**
- [spec-driven.md](file://spec-driven.md#L350-L400)

## 结论

Spec-Kit的核心工作流通过一系列斜杠命令实现了规范驱动开发的自动化闭环。从`/constitution`建立项目原则，到`/specify`生成功能规格，再到`/plan`、`/tasks`、`/analyze`和`/implement`完成技术实现，每个命令都在特定阶段发挥关键作用。

这一工作流的优势在于：
- **结构化**：通过模板确保输出的一致性和完整性
- **自动化**：减少手动操作，提高开发效率
- **可追溯**：从需求到实现的完整追溯链
- **高质量**：通过多层检查确保输出质量

通过理解和掌握这一核心工作流，开发团队可以更高效地将创意转化为高质量的软件产品，同时保持架构的一致性和可维护性。