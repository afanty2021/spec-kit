# 常见问题解答

<cite>
**本文档中引用的文件**  
- [SUPPORT.md](file://SUPPORT.md)
- [spec-driven.md](file://spec-driven.md)
- [README.md](file://README.md)
- [AGENTS.md](file://AGENTS.md)
- [memory/constitution.md](file://memory/constitution.md)
- [templates/spec-template.md](file://templates/spec-template.md)
- [templates/plan-template.md](file://templates/plan-template.md)
- [templates/tasks-template.md](file://templates/tasks-template.md)
- [scripts/bash/create-new-feature.sh](file://scripts/bash/create-new-feature.sh)
- [scripts/powershell/create-new-feature.ps1](file://scripts/powershell/create-new-feature.ps1)
</cite>

## 目录
1. [什么是规范驱动开发？](#什么是规范驱动开发)
2. [/specify 命令如何工作？](#specify-命令如何工作)
3. 如何更改默认的AI代理？
4. 支持哪些AI代理？
5. 什么是项目宪法（Constitution）？
6. 如何处理规格中的模糊需求？
7. /plan 命令的作用是什么？
8. /tasks 命令如何生成任务列表？
9. 如何在没有Git的环境中使用Spec-Kit？
10. 如何确保生成的代码符合架构原则？

## 什么是规范驱动开发？

规范驱动开发（Specification-Driven Development, SDD）是一种颠覆传统软件开发范式的新型方法论。在传统开发中，代码是真理的来源，而规格文档只是辅助性的脚手架，一旦编码开始便被抛弃。SDD则彻底反转了这种权力结构：**规格文档不再服务于代码，而是代码服务于规格文档**。

在SDD中，产品需求文档（PRD）不是指导开发的指南，而是生成实现的源头。技术方案不再是影响编码的文档，而是产生代码的精确定义。AI能够理解并实现复杂的规格，并创建详细的技术方案。SDD通过提供结构化的规格和后续的实施方案，确保其足够精确、完整且无歧义，从而能够生成可工作的系统。规格文档成为主要产物，而代码则成为其在特定语言和框架中的表达。

这种方法消除了规格与实现之间的鸿沟，因为两者之间的差距被消除，只剩下转换。维护软件意味着演进规格，调试意味着修复生成错误代码的规格和实施方案，重构意味着为清晰度而重新组织。整个开发工作流围绕规格作为单一事实来源重新组织，而实施方案和代码则成为持续再生的输出。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L1-L50)
- [README.md](file://README.md#L20-L35)

## /specify 命令如何工作？

`/specify` 命令是规范驱动开发流程的起点，它将一个简单的功能描述（用户提示）自动转换为一个完整、结构化的规格文档，并管理相关的仓库操作。其工作流程如下：

1.  **自动功能编号**：扫描现有的规格文档，确定下一个功能编号（例如，001, 002, 003）。
2.  **分支创建**：根据您的描述生成一个语义化的分支名称（如 `003-chat-system`）并自动创建该分支。
3.  **模板化生成**：复制并定制功能规格模板，将您的需求填充进去。
4.  **目录结构创建**：在 `specs/[branch-name]/` 下创建正确的目录结构，用于存放所有相关文档。

该命令的核心脚本（`create-new-feature.sh` 和 `create-new-feature.ps1`）通过解析用户输入、计算下一个功能编号、生成分支名、创建目录，并从模板复制 `spec.md` 文件来实现这一自动化流程。此命令确保了所有新功能都遵循一致的命名和结构约定。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L345-L365)
- [README.md](file://README.md#L120-L125)
- [scripts/bash/create-new-feature.sh](file://scripts/bash/create-new-feature.sh#L1-L98)
- [scripts/powershell/create-new-feature.ps1](file://scripts/powershell/create-new-feature.ps1#L1-L118)

## 如何更改默认的AI代理？

您可以在使用 `specify init` 命令初始化新项目时，通过 `--ai` 选项指定您希望使用的AI代理。支持的代理包括 `claude`, `gemini`, `copilot`, `cursor`, `qwen`, `opencode`, `codex`, `windsurf`, `kilocode`, `auggie`, 或 `roo`。

例如，要使用GitHub Copilot初始化项目，您可以运行：
```bash
specify init my-project --ai copilot
```

此命令会根据您选择的AI代理，生成相应的命令文件和目录结构（例如，为Claude Code生成 `.claude/commands/`，为GitHub Copilot生成 `.github/prompts/`）。您也可以在 `pyproject.toml` 文件中修改 `AI_CHOICES` 字典来添加对新AI代理的支持。

**Section sources**
- [README.md](file://README.md#L100-L115)
- [AGENTS.md](file://AGENTS.md#L30-L50)
- [src/specify_cli/__init__.py](file://src/specify_cli/__init__.py#L30-L50)

## 支持哪些AI代理？

Spec-Kit支持多种AI代理，分为CLI（命令行界面）和IDE（集成开发环境）两类：

| AI代理 | 类型 | 支持状态 | 备注 |
| :--- | :--- | :--- | :--- |
| **Claude Code** | CLI | ✅ 完全支持 | 需要安装 `claude` CLI工具 |
| **GitHub Copilot** | IDE | ✅ 完全支持 | 内置于VS Code等编辑器中 |
| **Gemini CLI** | CLI | ✅ 完全支持 | 需要安装 `gemini` CLI工具 |
| **Cursor** | CLI | ✅ 完全支持 | 需要安装 `cursor-agent` CLI工具 |
| **Qwen Code** | CLI | ✅ 完全支持 | 需要安装 `qwen` CLI工具 |
| **opencode** | CLI | ✅ 完全支持 | 需要安装 `opencode` CLI工具 |
| **Windsurf** | IDE | ✅ 完全支持 | 内置于Windsurf IDE中 |
| **Kilo Code** | CLI | ✅ 完全支持 | 需要安装 `kilocode` CLI工具 |
| **Auggie CLI** | CLI | ✅ 完全支持 | 需要安装 `auggie` CLI工具 |
| **Roo Code** | CLI | ✅ 完全支持 | 需要安装 `roo` CLI工具 |
| **Codex CLI** | CLI | ⚠️ 有限支持 | 不支持自定义参数的斜杠命令 |

**Section sources**
- [README.md](file://README.md#L65-L95)
- [AGENTS.md](file://AGENTS.md#L55-L85)

## 什么是项目宪法（Constitution）？

项目宪法（`memory/constitution.md`）是规范驱动开发的核心，它是一套不可变的原则，规定了如何将规格转化为代码。宪法充当系统的架构DNA，确保每个生成的实现都保持一致性、简洁性和高质量。

宪法定义了九条基本原则，例如：
*   **库优先原则 (Library-First)**：每个功能都必须从一个独立的库开始。
*   **CLI接口强制 (CLI Interface)**：每个库都必须通过命令行接口暴露其功能。
*   **测试先行强制 (Test-First)**：在编写任何实现代码之前，必须先编写单元测试。
*   **简洁性与反抽象 (Simplicity & Anti-Abstraction)**：强制使用 ≤3 个项目，并直接使用框架功能而非包装它们。

这些原则通过实施计划模板中的“预实施门禁”（Pre-Implementation Gates）来强制执行，确保AI在生成代码时遵守架构纪律。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L420-L480)
- [memory/constitution.md](file://memory/constitution.md#L1-L50)

## 如何处理规格中的模糊需求？

SDD流程通过强制标记和澄清步骤来处理模糊需求。在使用 `/specify` 命令生成初始规格时，模板会要求AI将所有不明确的地方标记为 `[NEEDS CLARIFICATION: specific question]`，而不是做出假设。

例如，如果用户需求是“创建一个登录系统”，但未指定认证方式，AI必须将其标记为 `[NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]`。

在进入 `/plan` 命令之前，必须运行 `/clarify` 命令来解决所有这些标记。这个结构化的澄清工作流会提出一系列问题，直到所有不确定性都被消除，从而确保规格的完整性和无歧义性。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L380-L395)
- [templates/spec-template.md](file://templates/spec-template.md#L40-L50)

## /plan 命令的作用是什么？

`/plan` 命令在功能规格创建后使用，用于生成一个全面的技术实施方案。其主要作用包括：

1.  **规格分析**：读取并理解功能需求、用户故事和验收标准。
2.  **宪法合规性检查**：确保技术方案与项目宪法和架构原则保持一致。
3.  **技术转化**：将业务需求转化为技术架构和实现细节。
4.  **详细文档生成**：生成数据模型、API契约和测试场景等支持性文档。
5.  **快速启动验证**：生成一个快速启动指南，捕捉关键的验证场景。

该命令的输出是一个 `plan.md` 文件，其中包含了技术上下文、项目结构、研究阶段（Phase 0）和设计阶段（Phase 1）的详细计划。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L367-L375)
- [templates/plan-template.md](file://templates/plan-template.md#L1-L226)

## /tasks 命令如何生成任务列表？

`/tasks` 命令在生成实施方案后使用，它会分析 `plan.md` 以及相关的 `data-model.md`、`contracts/` 和 `research.md` 等设计文档，从而生成一个可执行的任务列表。

其工作原理如下：
1.  **输入解析**：加载 `plan.md` 和其他可选的设计文档。
2.  **任务推导**：将契约（contracts）转换为契约测试任务，将实体（entities）转换为模型创建任务，将场景（scenarios）转换为集成测试任务。
3.  **并行化**：为独立的任务标记 `[P]`，并概述安全的并行执行组。
4.  **输出**：在功能目录下生成 `tasks.md` 文件，其中包含一个有序的、可由任务代理执行的任务列表。

该命令遵循测试驱动开发（TDD）的顺序，确保测试任务在实现任务之前。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L377-L385)
- [templates/tasks-template.md](file://templates/tasks-template.md#L1-L127)

## 如何在没有Git的环境中使用Spec-Kit？

Spec-Kit可以在没有Git的环境中使用。当使用 `specify init` 命令时，可以通过 `--no-git` 标志跳过Git仓库的初始化。

在这种情况下，系统会通过搜索 `.specify` 目录来确定仓库根目录。环境变量 `SPECIFY_FEATURE` 用于覆盖功能检测，允许您在非Git仓库中指定要工作的功能目录名称（例如，`001-photo-albums`）。`create-new-feature` 脚本在检测到没有Git时，会发出警告但继续创建功能目录和规格文件。

**Section sources**
- [README.md](file://README.md#L110-L112)
- [scripts/bash/create-new-feature.sh](file://scripts/bash/create-new-feature.sh#L30-L50)
- [scripts/powershell/create-new-feature.ps1](file://scripts/powershell/create-new-feature.ps1#L30-L50)

## 如何确保生成的代码符合架构原则？

通过项目宪法（Constitution）和模板中的门禁检查（Gates）来确保生成的代码符合架构原则。具体机制如下：

1.  **宪法作为基础**：`memory/constitution.md` 文件定义了所有必须遵守的不可变原则。
2.  **模板强制执行**：`plan-template.md` 中包含“预实施门禁”（Pre-Implementation Gates）部分，例如“简洁性门禁”（Simplicity Gate）和“反抽象门禁”（Anti-Abstraction Gate）。
3.  **自动化检查**：在生成实施方案的过程中，AI必须检查这些门禁。如果违反，必须在“复杂性跟踪”（Complexity Tracking）部分中记录理由，否则必须简化方案。
4.  **持续验证**：在设计阶段后，会重新检查宪法合规性，形成一个反馈循环。

这种机制将架构原则从一个规则手册转变为一个主动的架构伙伴，确保生成的代码不仅是功能性的，而且是可维护、可测试且架构健全的。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L482-L500)
- [templates/plan-template.md](file://templates/plan-template.md#L100-L120)