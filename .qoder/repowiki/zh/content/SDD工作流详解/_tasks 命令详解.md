# /tasks 命令详解

<cite>
**本文档引用的文件**
- [tasks-template.md](file://templates/tasks-template.md)
- [spec-driven.md](file://spec-driven.md)
- [plan-template.md](file://templates/plan-template.md)
- [commands/tasks.md](file://templates/commands/tasks.md)
</cite>

## 目录
1. [简介](#简介)
2. [任务分解算法](#任务分解算法)
3. [任务模板结构](#任务模板结构)
4. [任务列表的执行与跟踪](#任务列表的执行与跟踪)
5. [实际示例](#实际示例)
6. [挑战与解决方案](#挑战与解决方案)

## 简介

`/tasks` 命令是规范驱动开发（SDD）工作流中的关键环节，负责将 `/plan` 命令生成的实现计划分解为具体的、可执行的开发任务列表。该命令通过分析 `plan.md` 及其相关的设计文档，自动生成一个结构化的 `tasks.md` 文件，为后续的自动化执行或人工分配提供明确的指导。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L95-L103)

## 任务分解算法

`/tasks` 命令的核心是一个系统化的任务分解算法，该算法将高层次的设计决策转化为一系列原子化的、有序的开发任务。

### 输入与处理流程

该命令的执行流程如下：
1.  **加载主计划**：从功能目录中读取 `plan.md` 文件，提取技术栈、库和项目结构等核心信息。
2.  **加载可选设计文档**：
    *   **data-model.md**：提取实体（Entities）以生成模型创建任务。
    *   **contracts/**：将每个合同文件转换为一个契约测试任务。
    *   **research.md**：提取技术决策以生成环境设置任务。
3.  **按类别生成任务**：任务被系统地分为五个阶段：
    *   **Setup（设置）**：项目初始化、依赖项安装、代码格式化工具配置。
    *   **Tests（测试）**：契约测试、集成测试。
    *   **Core（核心）**：模型、服务、CLI 命令的实现。
    *   **Integration（集成）**：数据库连接、中间件、日志记录。
    *   **Polish（完善）**：单元测试、性能测试、文档更新。

**Section sources**
- [tasks-template.md](file://templates/tasks-template.md#L0-L42)

### 并行化与依赖关系识别

算法通过以下规则智能地识别并行化机会并标记任务依赖关系：
*   **并行化标记 `[P]`**：当两个任务操作不同的文件且无直接依赖时，它们被标记为 `[P]`，表示可以安全地并行执行。例如，为不同实体创建模型或为不同端点编写契约测试。
*   **依赖关系强制**：算法强制执行严格的依赖顺序，确保开发流程的正确性。关键的依赖规则包括：
    *   **测试优先（TDD）**：所有测试任务（T004-T007）必须在任何实现任务（T008-T014）之前完成。
    *   **实现顺序**：模型创建（T008）必须在服务实现（T009）和数据库连接（T015）之前完成。
    *   **集成顺序**：认证中间件（T016）必须在配置 CORS 和安全头（T018）之前完成。

这些规则确保了任务列表不仅是一个待办事项清单，更是一个遵循最佳实践的、可执行的开发蓝图。

**Section sources**
- [tasks-template.md](file://templates/tasks-template.md#L0-L42)
- [tasks-template.md](file://templates/tasks-template.md#L99-L117)

### 任务粒度控制

为了确保任务的可管理性和原子性，算法遵循以下原则来控制任务粒度：
*   **单一职责**：每个任务应专注于一个明确的目标，例如“在 `src/models/user.py` 中创建用户模型”。
*   **文件级粒度**：如果多个任务需要修改同一个文件，它们将被标记为非并行（无 `[P]`），并按顺序执行，以避免冲突。
*   **具体路径**：每个任务都包含精确的文件路径，消除了执行时的歧义。

**Section sources**
- [tasks-template.md](file://templates/tasks-template.md#L0-L42)

## 任务模板结构

`tasks-template.md` 模板是 `/tasks` 命令的基石，它通过结构化的约束来规范 AI 的输出，确保生成的任务列表具有一致性和高质量。

### 模板的关键组成部分

1.  **执行流程（main）**：这是一个详细的算法伪代码，定义了命令的每一步操作，从加载文档到最终验证，为 AI 提供了清晰的执行蓝图。
2.  **任务格式规范**：明确规定了任务的格式为 `[ID] [P?] Description`，其中 `[P]` 标记并行性，并强制要求在描述中包含精确的文件路径。
3.  **路径约定**：根据项目类型（单项目、Web 应用、移动应用）定义了标准的源代码和测试目录结构，确保了项目组织的一致性。
4.  **任务生成规则**：明确列出了从不同设计文档生成任务的规则，例如“每个合同文件 → 契约测试任务 `[P]`”。
5.  **验证检查清单**：在返回成功之前，命令会执行一个严格的检查，确保：
    *   所有合同都有对应的测试。
    *   所有实体都有模型任务。
    *   所有测试都在实现之前。
    *   并行任务确实是独立的。
    *   每个任务都指定了确切的文件路径。

这个模板通过提供一个“约束性提示”（constrained prompt），有效地引导 AI 生成符合工程规范的输出，而不是模糊或冗余的指令。

**Section sources**
- [tasks-template.md](file://templates/tasks-template.md#L0-L126)

## 任务列表的执行与跟踪

生成的 `tasks.md` 文件不仅是一个静态列表，更是一个支持后续执行和状态跟踪的动态工件。

### 支持自动化执行

`tasks.md` 的设计使其非常适合自动化执行：
*   **原子化任务**：每个任务都是一个独立的、可执行的单元，可以被任务代理（Task agent）逐一处理。
*   **并行执行示例**：模板中包含的并行执行示例（如同时启动 T004-T007）为自动化工具提供了明确的并行化策略。
*   **精确的文件路径**：为自动化工具定位和修改代码提供了精确的指引。

### 人工分配与状态跟踪

对于人工开发团队，`tasks.md` 提供了清晰的分工依据：
*   **任务编号**：使用 `T001`, `T002` 等编号，便于追踪和沟通。
*   **依赖图**：生成的依赖图（在 `tasks-template.md` 中提及）清晰地展示了任务间的先后顺序，帮助团队理解工作流。
*   **状态管理**：团队可以使用版本控制系统或项目管理工具，通过提交信息或更新任务状态来跟踪每个任务的完成情况（如 `T001: done`, `T002: in progress`）。

**Section sources**
- [tasks-template.md](file://templates/tasks-template.md#L0-L126)

## 实际示例

以开发一个名为 "Create Taskify" 的看板式任务管理平台为例，`/tasks` 命令会如何分解一个复杂的技术方案。

假设 `plan.md` 中定义了用户、项目、任务和评论等实体，以及创建、更新、删除等 API 端点。

1.  **Setup 阶段**：生成 `T001` 创建项目结构，`T002` 初始化 Python 项目，`T003 [P]` 配置 linting 工具。
2.  **Tests 阶段**：并行生成多个契约测试任务，如 `T004 [P]` 为 `POST /api/projects` 编写测试，`T005 [P]` 为 `GET /api/tasks` 编写测试。
3.  **Core 阶段**：在测试通过后，开始实现核心功能，如 `T008 [P]` 在 `src/models/user.py` 中创建用户模型，`T009 [P]` 在 `src/services/project_service.py` 中实现项目服务。
4.  **Integration 阶段**：连接服务与数据库，如 `T015` 将 `UserService` 连接到数据库。
5.  **Polish 阶段**：最后进行完善，如 `T019 [P]` 为验证逻辑编写单元测试，`T021 [P]` 更新 API 文档。

这个有序的、分阶段的列表确保了开发过程的系统性和可预测性。

**Section sources**
- [spec-driven.md](file://spec-driven.md#L236-L253)
- [README.md](file://README.md#L254-L292)

## 挑战与解决方案

在任务分解过程中可能会遇到一些挑战，但该系统提供了相应的解决方案。

### 挑战一：模糊的输入

如果 `plan.md` 或 `data-model.md` 中的描述模糊不清，可能导致生成的任务不明确。

**解决方案**：`/plan` 命令本身会强制使用 `[NEEDS CLARIFICATION]` 标记来标识所有不确定性。`/tasks` 命令依赖于这些清晰的输入，因此模糊性问题在上游就被解决了。

### 挑战二：过度并行化导致冲突

算法可能错误地将需要共享状态或资源的任务标记为 `[P]`。

**解决方案**：通过严格的“文件级”并行化规则来规避。只要两个任务修改同一个文件，它们就不会被标记为 `[P]`，从而避免了大部分代码冲突。此外，验证检查清单会确保并行任务的独立性。

### 挑战三：任务粒度过粗

有时，一个任务可能仍然过于庞大，难以一次性完成。

**解决方案**：虽然 `/tasks` 命令生成了主要任务，但开发人员在执行时可以将一个大任务（如 `T011 POST /api/users endpoint`）进一步拆分为更小的子任务（如“解析请求体”、“调用服务层”、“返回响应”），并在提交信息中体现。

**Section sources**
- [tasks-template.md](file://templates/tasks-template.md#L118-L126)
- [plan-template.md](file://templates/plan-template.md#L130-L171)