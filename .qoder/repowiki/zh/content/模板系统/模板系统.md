# 模板系统

<cite>
**本文档中引用的文件**  
- [analyze.md](file://templates/commands/analyze.md)
- [clarify.md](file://templates/commands/clarify.md)
- [constitution.md](file://templates/commands/constitution.md)
- [implement.md](file://templates/commands/implement.md)
- [plan.md](file://templates/commands/plan.md)
- [specify.md](file://templates/commands/specify.md)
- [tasks.md](file://templates/commands/tasks.md)
- [spec-template.md](file://templates/spec-template.md)
- [plan-template.md](file://templates/plan-template.md)
- [tasks-template.md](file://templates/tasks-template.md)
- [agent-file-template.md](file://templates/agent-file-template.md)
- [constitution.md](file://memory/constitution.md)
- [check-prerequisites.sh](file://scripts/bash/check-prerequisites.sh)
- [setup-plan.sh](file://scripts/bash/setup-plan.sh)
</cite>

## 目录
1. [引言](#引言)  
2. [命令模板分析](#命令模板分析)  
3. [文档模板结构](#文档模板结构)  
4. [模板设计最佳实践](#模板设计最佳实践)  
5. [自定义与扩展指南](#自定义与扩展指南)  
6. [结论](#结论)

## 引言

Spec-Kit 是一个基于模板驱动的自动化开发框架，其核心机制依赖于一组结构化模板来引导 AI 代理完成从需求分析到代码实现的完整流程。这些模板不仅是文档生成的蓝图，更是自动化引擎的行为规范。通过精确的指令、占位符和脚本调用逻辑，模板系统确保了开发过程的可重复性、一致性和高质量。

本深度文档旨在揭示 Spec-Kit 模板系统的内部工作机制。我们将首先剖析命令模板（`/templates/commands/*.md`），理解它们如何定义每个斜杠命令（如 `/specify`, `/plan`）的执行逻辑。随后，我们将深入分析核心文档模板（`spec-template.md`, `plan-template.md`, `tasks-template.md`）的结构和字段含义，阐明它们如何被脚本填充并生成最终的规范、计划和任务文档。最后，我们将探讨模板设计的最佳实践，并提供自定义和扩展模板的实用指南。

**Section sources**  
- [spec-template.md](file://templates/spec-template.md#L1-L117)  
- [plan-template.md](file://templates/plan-template.md#L1-L226)  
- [tasks-template.md](file://templates/tasks-template.md#L1-L127)

## 命令模板分析

命令模板位于 `templates/commands/` 目录下，是 Spec-Kit 自动化流程的入口点。每个 `.md` 文件对应一个斜杠命令（如 `/specify`），其内容不仅定义了用户可见的指令，还包含了底层的执行逻辑和脚本调用。

### 命令模板结构

所有命令模板均采用统一的 YAML 元数据头和 Markdown 主体结构。

**元数据头（Metadata Header）**  
```yaml
---
description: 对命令功能的简要描述。
scripts:
  sh: 对应的 Bash 脚本路径和参数
  ps: 对应的 PowerShell 脚本路径和参数
---
```
此部分定义了命令的描述和跨平台执行脚本。例如，`/specify` 命令会调用 `create-new-feature.sh` 脚本来初始化新功能分支和规范文件。

**主体内容（Main Content）**  
主体部分是 AI 代理的执行指南，包含以下关键元素：
- **目标（Goal）**: 明确该命令的最终目的。
- **执行步骤（Execution steps）**: 详细的、分步骤的操作流程。
- **行为规则（Behavior rules）**: 约束 AI 代理行为的硬性规定。
- **占位符（Placeholders）**: 如 `$ARGUMENTS` 和 `{SCRIPT}`，在运行时被替换为实际值。

### 核心命令模板详解

#### `/specify` 命令模板
`/templates/commands/specify.md` 是整个流程的起点。它负责根据用户的自然语言描述创建初始的 `spec.md` 文件。

**Section sources**  
- [specify.md](file://templates/commands/specify.md#L1-L25)

#### `/clarify` 命令模板
`/templates/commands/clarify.md` 用于消除规范中的模糊性。它会主动向用户提出最多 5 个高度针对性的澄清问题，并将答案直接编码回 `spec.md` 文件中。

**Section sources**  
- [clarify.md](file://templates/commands/clarify.md#L1-L162)

#### `/plan` 命令模板
`/templates/commands/plan.md` 负责执行实现规划流程。它会加载 `plan-template.md` 并引导 AI 代理生成设计文档，如 `research.md` 和 `data-model.md`。

**Section sources**  
- [plan.md](file://templates/commands/plan.md#L1-L47)

#### `/tasks` 命令模板
`/templates/commands/tasks.md` 基于已有的设计文档（如 `plan.md`, `data-model.md`）生成一个可执行的、按依赖关系排序的 `tasks.md` 文件。

**Section sources**  
- [tasks.md](file://templates/commands/tasks.md#L1-L66)

#### `/implement` 命令模板
`/templates/commands/implement.md` 是执行阶段的命令，它会解析 `tasks.md` 并按计划执行所有任务，遵循 TDD（测试驱动开发）等原则。

**Section sources**  
- [implement.md](file://templates/commands/implement.md#L1-L59)

#### `/analyze` 命令模板
`/templates/commands/analyze.md` 在任务生成后执行，对 `spec.md`、`plan.md` 和 `tasks.md` 进行一致性、质量和宪法对齐分析，输出一份结构化的分析报告。

**Section sources**  
- [analyze.md](file://templates/commands/analyze.md#L1-L105)

#### `/constitution` 命令模板
`/templates/commands/constitution.md` 用于创建或更新项目宪法（`/memory/constitution.md`），并确保所有相关模板和文档与之保持同步。

**Section sources**  
- [constitution.md](file://templates/commands/constitution.md#L1-L74)

## 文档模板结构

文档模板是生成最终开发工件的骨架。它们定义了文档的结构、必需的字段以及生成逻辑。

### 规范模板（spec-template.md）

`spec-template.md` 是生成功能规范（`spec.md`）的模板。其核心是“执行流程（main）”代码块，它定义了从用户输入到最终规范的自动化生成步骤。

**关键结构**：
- **执行流程（main）**: 一个伪代码块，指导 AI 代理如何解析用户描述、提取关键概念、标记模糊点并填充规范。
- **快速指南（Quick Guidelines）**: 提供编写规范的准则，强调“关注 WHAT 而非 HOW”。
- **用户场景与测试**: 强制要求定义主要用户故事和验收场景。
- **功能需求**: 要求每个需求都必须是可测试的，并使用 `[NEEDS CLARIFICATION]` 标记模糊点。
- **审查与验收清单**: 一个自动化检查清单，确保规范质量。

**Section sources**  
- [spec-template.md](file://templates/spec-template.md#L1-L117)

### 计划模板（plan-template.md）

`plan-template.md` 是生成实现计划（`plan.md`）的模板。它比规范模板更复杂，因为它需要整合技术上下文和宪法检查。

**关键结构**：
- **执行流程（/plan command scope）**: 定义了 `/plan` 命令的执行范围，明确指出该命令在生成设计文档后停止，任务生成由 `/tasks` 命令完成。
- **技术上下文（Technical Context）**: 包含项目的技术栈、依赖、存储、性能目标等信息，其中 `NEEDS CLARIFICATION` 占位符会触发 `/clarify` 流程。
- **宪法检查（Constitution Check）**: 一个关键的质量门禁，确保设计符合项目宪法。
- **项目结构（Project Structure）**: 提供了不同项目类型（单体、Web、移动）的源代码结构示例。
- **阶段划分（Phase 0, 1, 2）**: 清晰地划分了研究、设计和任务规划三个阶段。

**Section sources**  
- [plan-template.md](file://templates/plan-template.md#L1-L226)

### 任务模板（tasks-template.md）

`tasks-template.md` 是生成可执行任务列表（`tasks.md`）的模板。它定义了任务的分类、格式和生成规则。

**关键结构**：
- **执行流程（main）**: 描述了如何从 `plan.md` 和其他设计文档中提取信息来生成任务。
- **任务格式**: 明确规定了任务的 ID、并行标记 `[P]` 和描述。
- **阶段划分**: 将任务分为“设置”、“测试”、“核心实现”、“集成”和“润色”五个阶段，并强调 TDD 原则（测试先行）。
- **依赖关系**: 列出了任务间的依赖，确保执行顺序正确。
- **并行示例**: 提供了如何并行执行任务的示例。
- **任务生成规则**: 详细说明了如何从合同、数据模型和用户故事生成具体任务。

**Section sources**  
- [tasks-template.md](file://templates/tasks-template.md#L1-L127)

### 代理文件模板（agent-file-template.md）

`agent-file-template.md` 用于生成或更新项目根目录下的 `AGENTS.md` 文件，该文件为 AI 代理提供实时的项目上下文，包括当前使用的技术栈、项目结构和近期变更。

**Section sources**  
- [agent-file-template.md](file://templates/agent-file-template.md#L1-L23)

## 模板设计最佳实践

### 编写清晰的指令

1. **明确目标**: 每个模板的 `Goal` 部分必须清晰无误，让 AI 代理确切知道要达成什么。
2. **分步指导**: 使用编号列表将复杂流程分解为原子步骤，降低 AI 理解的难度。
3. **使用强约束**: 在 `Behavior rules` 中使用“必须”、“禁止”、“永不”等强约束性词汇，减少歧义。
4. **提供示例**: 在模板中包含具体的、可复制的示例（如 `tasks-template.md` 中的并行执行示例），能有效引导 AI 生成符合预期的输出。

### 设计高效的占位符

1. **语义化命名**: 使用如 `$ARGUMENTS`、`{SCRIPT}` 这样语义清晰的占位符，便于在脚本中进行替换。
2. **状态标记**: 使用 `[NEEDS CLARIFICATION]` 这样的特殊标记，不仅能提示 AI，还能作为自动化流程的触发点（如触发 `/clarify` 命令）。
3. **版本与日期**: 在宪法等文件中使用 `[CONSTITUTION_VERSION]`、`[DATE]` 等占位符，确保信息的动态更新。

### 确保信息完整性

1. **强制性检查清单**: 利用 `Review & Acceptance Checklist` 这样的结构，强制 AI 在生成文档时进行自我验证。
2. **依赖性检查**: 在命令模板中通过脚本（如 `check-prerequisites.sh`）检查前置条件，确保流程的连贯性。例如，`/plan` 命令会检查 `spec.md` 是否存在。
3. **宪法对齐**: 将 `Constitution Check` 作为质量门禁，确保所有设计和实现都符合项目的根本原则。

**Section sources**  
- [spec-template.md](file://templates/spec-template.md#L1-L117)  
- [plan-template.md](file://templates/plan-template.md#L1-L226)  
- [check-prerequisites.sh](file://scripts/bash/check-prerequisites.sh#L1-L166)

## 自定义与扩展指南

### 自定义命令模板

用户可以根据项目需求修改现有的命令模板。例如，可以修改 `/implement.md` 的行为规则，以适应特定的代码审查流程。修改时，应确保：
- 保持 YAML 元数据头的结构。
- 更新 `description` 以反映新功能。
- 调整 `scripts` 字段以指向自定义脚本。
- 仔细审查 `Execution steps` 和 `Behavior rules`，确保逻辑正确。

### 扩展文档模板

1. **添加新字段**: 可以在 `spec-template.md` 中添加新的可选章节，如“合规性要求”或“第三方依赖”。
2. **修改生成逻辑**: 可以调整 `Execution Flow` 代码块，改变文档的生成流程。例如，可以要求在生成计划前必须完成安全审查。
3. **创建新模板**: 可以创建全新的模板来支持新的工件类型，如 `security-review-template.md`。

### 扩展脚本功能

模板中调用的 Bash/PowerShell 脚本是扩展系统功能的关键。用户可以通过修改 `scripts/` 目录下的脚本来自定义检查逻辑、路径生成或与外部工具的集成。

**Section sources**  
- [specify.md](file://templates/commands/specify.md#L1-L25)  
- [setup-plan.sh](file://scripts/bash/setup-plan.sh#L1-L61)  
- [check-prerequisites.sh](file://scripts/bash/check-prerequisites.sh#L1-L166)

## 结论

Spec-Kit 的模板系统是一个强大而精密的自动化引擎。通过将开发流程分解为一系列结构化的模板，它实现了从模糊的用户需求到精确的可执行任务的自动化转换。命令模板定义了“做什么”和“何时做”，而文档模板则定义了“做成什么样”。两者通过脚本和占位符紧密耦合，形成了一个闭环的、可验证的开发工作流。

深入理解这些模板的结构和设计原则，是有效利用 Spec-Kit 的关键。遵循最佳实践，用户可以创建出清晰、完整且可维护的模板，从而显著提升开发效率和软件质量。通过自定义和扩展，该系统可以适应各种项目和团队的需求，成为推动自动化开发的强大基石。